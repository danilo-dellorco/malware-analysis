---
title: "Homework 1 Malware Analysis"
author: Danilo Dell'Orco, 0300229
date: "2021-10-27"
subject: "Markdown"
keywords: [Markdown, Example]
lang: "en"
footer-left: ""
footer-right: "\\thepage"
titlepage: true
titlepage-rule-height: 0.5
book: true
classoption: oneside
code-block-font-size: \scriptsize

...

# Homework 1 Malware Analysis - Danilo Dell'Orco 0300229
Il punto di partenza per capire il funzionamento di questo programma, è quello di individuare il *main*, in modo tale da poter seguire il flusso di esecuzione e le strutture dati che vengono man mano utilizzate.

## Ricerca del main
Utilizziamo quindi lo strumento **Function Call Graph** sull'entry point per avere una prima panoramica sulle funzioni invocate.

\begin{center}
  \includegraphics[width=\textwidth]{img/entry.png}
\end{center}

Sono presenti diverse funzioni non riconosciute da Ghidra (FUN_xxxxxxxx) che dobbiamo quindi analizzare singolarmente per individuare quale rappresenta il main del programma.

### FUN 004019a0  

\begin{center}
  \includegraphics[width=0.4\textwidth]{img/004019a0.png}
\end{center}

Questa funzione **non è il main**, in quanto viene invocata sia dall'entry point che da un'altra funzione *00402a30*. Ci si aspetta infatti che il main non venga invocato da altre funzioni.


### FUN_00402a30
\begin{center}
  \includegraphics[width=0.5\textwidth]{img/00402a30.png}
\end{center}

Questa funzione rappresenta un **probabile main**, in quanto:

- Viene invocata direttamente dall'entry point
- Invoca altre 3 funzioni definite dal programmatore
- Invoca la funzione di libreria **atoi**, che effettua il parsing di una stringa in un intero. Questa potrebbe essere ad esempio utilizzata per convertire un argomento da riga di comando in un valore numerico.
<br />

### FUN_004019e0
![](img/004019e0.png)

Questa funzione **non è il main** del programma, in quanto invoca soltanto funzioni di libreria, ed è probabilmente utilizzata per inizializzare l'ambiente di esecuzione.


### FUN_00402480
![](img/00402480.png)

Questa funzione sicuramente **non è il main**, in quanto viene invocata da delle callback.

### FUN_00401e60
![](img/00401e60.png)

Questa funzione è un **probabile main**, in quanto invoca 4 funzioni user-defined ed una funzione **VirtualProtect**.


### Main: FUN_00402a30
Le funzioni *00402e60* e *00402a30* sono due possibili main, per cui è necessario analizzarle più nel dettaglio.
**FUN_00401e60** invoca *VirtualProtect*, che modifica la protezione su un'area di indirizzi virtuali del processo chiamante. Essendo una chiamata di basso livello, è molto più probabile che venga invocata dall'entry point per il setup dell'ambiente, rispetto ad una chiamata esplicita nel main da parte del programmatore. 

Analizziamo quindi il codice di **FUN_00402a30** per vedere se rappresenta effettivamente il main del programma.

![](img/00402a30_det0.png)

In input prende due parametri, che potrebbero corrispondere ad **argc** ed **argv**, ovvero gli argomenti tradizionali della funzione *main* (che potrebbero essere argc e argv)

- **int param_1** corrisponde ad **argc** ed ha il tipo di dato corretto
- **int param_2** corrisponde ad **argv**, ma il tipo di dato è **int** invece che **char\*\*** delle

Analizziamo quindi il **codice assembly** per capire meglio come vengono utilizzati i parametri di questa funzione, e se effettimvamente param_2 può corrispondere ad argv.

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/nuovo_1.png}
\end{center}

Viene scritto il contenuto dell'indirizzo *[EBP+param_2]* nel registro *EBX*. In questo contesto ghidra com param_2 non indica il valore di *param_2*, ma il suo offset all'interno dello stack. In pratica quindi viene caricato param_2 in EBX. 

\newpage

Possiamo quindi dire che:

- ESI contiene param_1
- EBX contiene param_2

Successivamente nella label **LAB_00402a52**, viene copiato il valore contenuto all'indirizzo *[EBX+4]* nel *registro EAX*. Il contenuto di EAX viene poi copiato tramite *MOV* all'indirizzo puntato dallo *stack pointer*. Seguendo la convenzione cdecl si sta quindi passando un parametro alla funzione **atoi**.

Fatte queste considerazioni, risulta evidente che *param_2* debba essere necessariamente un **array di char\***, in quanto:

- ptr [EBX+4] corrisponde a argv[1]
- argv[1] viene passato come parametro ad *atoi*
- atoi accetta in input una stringa (quindi *char\**), da convertire in intero.

Un'ulteriore conferma di ciò si ha analizzando il codice fornito dal **decompilatore**, in cui param_2 viene castato a **(char\*\*)** prima di essere passato ad *atoi*

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/param_2.png}
\end{center}

Possiamo quindi affermare che effettivamente **FUN_00402a30** è il **main** del programma. Per questo andiamo a:

- Modificare il tipo di dato di param_2 in char**
- Rinominare *param_1* in *argc* e *param_2* in *argv*
- Rinominare *FUN_00402a30* in *main*

\newpage

## Analisi delle Funzioni
Una volta individuato il main, possiamo proseguire seguendo la logica del programma, analizzando la catena di funzioni che vengono invocate.

### Main (1)
Iniziamo proprio con l'analisi del main, andando a studiare nel dettaglio il suo comportamento.

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/new_0.png}
\end{center}


#### FUN_004019a0 (onexit_routine)\
Dopo il prologo vengono eseguite due *MOV* che copiano *argc in ESI* e *argv in EBX*.
Successivamente viene invocata la funzione *004019a0*. Questa, come visto in precedenza, viene chiamata anche dall'entry point, ed analizzandone il codice si vede che si occupa di impostare un'attività da eseguire all'*uscita dal programma*.

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/nuovo_5.png}
\end{center}

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/nuovo_6.png}
\end{center}

Non abbiamo tuttavia informazioni sufficienti per capire quale funzione venga settata, per cui ci limitiamo al momento a rinominare **FUN_004019a0** in **onexit_routine**.

#### Argomenti\
Successivamente si controlla se **argv[argc]** è **uguale a zero**.

\begin{center}
  \includegraphics[width=0.5\textwidth]{img/nuovo_7.png}
\end{center}

Analizziamo quindi l'assembly nel dettaglio:

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/main_2.png}
\end{center}

- *ESI* contiene argc
- *[EBX + ESI\*4]* è l'indirizzo di *argv[argc]* 
- tramite *MOV*, *argv[argc]* viene copiato in *EAX*
- con *TEST EAX, EAX* si verifica se EAX è uguale a zero, settando *Zero Flag* di conseguenza 
- con JZ si effettua il salto a **LAB_00402aac** se è lo ZF è impostato a 1

\begin{center}Zero Flag
  \includegraphics[width=0.6\textwidth]{img/main_4.png}
\end{center}

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/main_5.png}
\end{center}

Questa condizione risulta essere sempre verificata. Infatti, se vengono passati *N argomenti* da riga di comando, si avrà **argc = N+1** *(nome del programma + N argomenti)*. Quindi, **argv** avrà elementi *argv[0] ... argv[N]*, e di conseguenza **argc[N+1]** non avrà mai un valore diverso da zero.

Ciò vuol dire che a prescindere dal numero e tipo di parametri passati, il programma terminerà sempre. Ovviamente questo controllo non fà parte del flusso  di istruzioni originale, ma è una condizione inserita per non permettere esplicitamente l'esecuzione del programma.

\newpage

Continuando con l'analisi si effettua un ulteriore controllo sul numero di argomenti, verificando se argc <3. 

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/main_8.png}
\end{center}

In particolare, questo controllo viene effettuato tramite le istruzioni **CMP** e **JLE**.

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/main_6.png}
\end{center}

Si effettua il **compare** tra il valore *2* ed il contenuto del *registro ESI*. Solo se questo è inferiore o uguale a 2 viene effettuato il Jump alla label **LAB_00402a9c**.

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/main_7.png}
\end{center}

Questo ci indica quindi che il programma **accetta 2 argomenti da riga di comando**. Tuttavia se vengono passati meno di 2 argomenti (*argc<3*), non si và in errore, ma vengono settati argv[1] ed argv[2] a 0.

Vengono successivamente inizializzate due variabili **pHVar1** e **pcVar3**, passate poi in input alla funzione *FUN_004018a0*

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/main_9.png}
\end{center}

#### pHVar1\
HKEY associato ad argv[1]. Nel caso in cui argv[1] sia zero, *pHVar1* viene impostata di default a *0x80000002*. Dalla documentazione vediamo che tale codice corrisponde a **HKEY_LOCAL_MACHINE**, per cui possiamo assegnarlo su *ghidra* tramite la funzione **Set Equate**. Questo ci indica quindi come il primo parametro di FUN_004018a0 sia una Handle ad una **chiave di primo livello** del *Registro di Sistema Windows*

\begin{center}
  \includegraphics[width=0.4\textwidth]{img/doc_0.png}
\end{center}

#### pcVar3\
Stringa associata ad argv[2]. Nel caso in cui argv[2] sia zero, questa viene impostata al valore **"SYSTEM\\ControlSet001\\Control"**. Ciò ci indica come il secondo parametro di *FUN_004018a0* rappresenti il **path della subkey**, partendo dal registro di primo livello specificato tramite il primo parametro. 

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/doc_1.png}
\end{center}

\newpage

### FUN_004018a0 (open_key)
Analizziamo ora il codice della *prima funzione* chiamata nel *main*

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/open_0.png}
\end{center}

Analizzando il decompilato di tale funzione vediamo che viene invocata al suo interno la funzione di libreria **RegOpenKeyExA**. Dalla documentazione vediamo che questa consente di aprire la chiave di registro specificata. In particolare, i parametri che accetta sono:
```  
LSTATUS RegOpenKeyExA(
  [in]           HKEY   hKey,
  [in, optional] LPCSTR lpSubKey,
  [in]           DWORD  ulOptions,
  [in]           REGSAM samDesired,
  [out]          PHKEY  phkResult
);
```

I primi due parametri che passiamo alla funzione sono *param_1* e *param_2*, che corrispondono a *pHVar1* e *pcVar3* definiti nel main. Per uniformarci alla documentazione possiamo quindi rinominare questi parametri rispettivamente in **hkey** e **lpSubKey**. Il terzo parametro **ulOptions** viene passato pari a 0. 

Il quarto parametro **samDesired** indica i permessi con cui si vuole aprire la chiave. Questo è impostato a *0xf003f*, che corrisponde alla modalità *KEY_ALL_ACCESS*. Anche in questo caso utilizziamo quindi *Set Equate* per specificare il nome invece del codice numerico.

\begin{center}
  \includegraphics[width=0.8\textwidth]{img/doc_2.png}
\end{center}

L'ultimo argomento **phkResult** invece è un parametro di output, e contiene un puntatore ad una variabile che riceve un handle verso la chiave aperta.

\newpage

Possiamo quindi ridefinire alcune variabili utilizzate dal decompilatore, sfruttando le informazioni ricavate dalla documentazione. In particolare:

```
param_1      --> hkey
param_2      --> lpSubKeys
LVar1        --> openKeyRes
0xf003f      --> KEY_ALL_ACCESS
FUN_004018a0 --> open_key()
```

Il parametro **HKEY local_10 [3]** viene interpretato da Ghidra come un *array di HKEY*. Tuttavia possiamo osservare come nel **codice assembly** non viene mai effettuato un accesso del tipo *local_10 + offset*, e anche nel codice decompilato viene utilizzato solo il primo elemento *local_10[0]*. Pertanto utilizziamo la funzione di Ghidra **Retype Variable** per cambiare il tipo di dato da **HKEY [3]** in **HKEY**. Rinominiamo inoltre tale variabile in **phkResult**. 

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/open_4.png}
\end{center}

Dopo aver aperto la chiave, si controlla tramite un *if statement* il valore di ritorno di *RegOpenKeyExA*. Questa funzione ritorna **0** in caso di successo, ed in tal caso viene invocata la funzione **FUN_00401530**.

Questa funzione prende come parametro l'handler *phkResult* alla chiave aperta, che verrà successivamente chiusa tramite la chiamata di libreria **RegCloseKey**

### FUN_00401530 (read_registry)
Questa funzione risulta molto complessa, ed al suo interno vengono chiamate tre funzioni di libreria. Procediamo quindi analizzando separatamente i tre blocchi di codice.

- RegQueryInfoKeyA
- RegEnumKeyExA
- RegEnumValueA

\newpage

#### RegQueryInfoKeyA\
\begin{center}
  \includegraphics[width=0.6\textwidth]{img/read_0.png}
\end{center}

In questa porzione di codice:

- Viene allocata un'area di memoria di 52 byte (0x34) tramite **malloc**. L' indirizzo base di quest'area viene salvato in *ppCVar1*.
- Viene chiamata la funzione di libreria **RegQueryInfoKeyA**, che ottiene tutte le informazioni sulla chiave specificata.

Analizzando i parametri passati in input a *RegQueryInfoKeyA*, possiamo osservare che la variabile **ppCVar** viene utilizzata come una base per diversi accessi a memoria del tipo *ppCVar1 + offset*

Questo ci suggerisce che questa variabile rappresenta in realtà un **array** o una **struttura dati**. Analizziamo quindi i parametri di input di *RegQueryInfoKeyA*:

```
  [in]                HKEY      hKey,
  [out, optional]     LPSTR     lpClass,
  [in, out, optional] LPDWORD   lpcchClass,
                      LPDWORD   lpReserved,
  [out, optional]     LPDWORD   lpcSubKeys,
  [out, optional]     LPDWORD   lpcbMaxSubKeyLen,
  [out, optional]     LPDWORD   lpcbMaxClassLen,
  [out, optional]     LPDWORD   lpcValues,
  [out, optional]     LPDWORD   lpcbMaxValueNameLen,
  [out, optional]     LPDWORD   lpcbMaxValueLen,
  [out, optional]     LPDWORD   lpcbSecurityDescriptor,
  [out, optional]     PFILETIME lpftLastWriteTime
```
I tipi di dato non sono omogonei, ragione per cui *ppCVar1* rappresenta sicuramente una *struttura dati*. Definiamo quindi una nuova struttura chiamata **RegistryInfo**, avente dimensione pari a 52 bytes. Definiamo inoltre anche un puntatore a tale struttura (**RegistryInfo\***). 

\newpage


#### Struttura RegistryInfo (1)\
Dobbiamo ora definire i diversi **campi** di *RegistryInfo* ed i relativi **tipi di dato**. La funzione *RegQueryInfoKeyA*, ad eccezione del primo parametro *hkey*, richiede dei puntatori (LPSTR, LPDWORD, PFILETIME).

Andiamo quindi ad analizzare il codice assembly per vedere come vengono inseriti i campi della struttura sullo stack per il passaggio dei parametri a *RegQueryInfoKeyA*

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/read_1.png}
\end{center}

Il primo parametro *param_1* è già presente sullo stack, poiché passato dal chiamante.

Il secondo parametro *lpClass* rappresenta un puntatore ad un'area di 260 bytes. Questo valore è contenuto nel registro EAX (malloc ritorna in EAX), e viene scritto sullo stack tramite una MOV.

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/new_1.png}
\end{center}

Quindi il primo parametro della struttura, che corrisponde a *lpClass*, è un **LPSTR**

Tutti i restanti parametri vengono invece caricati sullo stack utilizzando l'istruzione **LEA** (*Load Effective Address*). Questa istruzione carica l'indirizzo sorgente nel registro di destinazione.

Nel *registro EBX* è salvato l'indirizzo base della struttura, per cui con *[EBX+offset]* si accede ai diversi campi. All'istruzione *RegQueryInfoKeyA* vengono quindi passati i puntatori ai campi di *RegistryInfo*.

Questa considerazione ci indica che, ad eccezione del primo, tutti i campi della struttura non sono dei puntatori (LPDWORD, PFILETIME), ma dei valori effettivi (DWORD, FILETIME) di cui verranno poi passati i puntatori a *RegQueryInfoKeyA*

\newpage

Possiamo quindi definire **RegistryInfo** come segue:

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/read_2.png}
\end{center}

Gli *ultimi 8 byte* sono per ora lasciati come *undefined*, in quanto non si hanno ancora sufficienti informazioni per definirli.

Modifichiamo a questo punto il tipo di dato della variabile *pcCVar1*, specificando *RegistryInfo\**. Vediamo che ora Ghidra riconosce correttamente la struttura dati.

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/read_3.png}
\end{center}

A seguito della chiamata di funzione, vengono scritte nei parametri di output le diverse informazioni riguardo la chiave di registro specificata. In particolare:

- **regInfo->subKeysNumber** contiene il numero di subkeys della chiave letta.
- **regInfo->valuesNumber** contiene il numero di values della chiave letta.

Successivamente si effettua un controllo sul valore di ritorno di *RegQueryInfoKeyA*. In caso di successo questa ritorna zero, altrimenti uno specifico codice di errore.

Nel caso in cui la funzione *non legga correttamente* le informazioni del registro (*index2!=0*) si effettua un **jump** alla label *info_key_exception* (ramo else). Qui viene stampato un codice di errore (puts), si azzera il puntatore alla struttura (EBX=0) e si effettua un altro jump alla label per il ritorno al chiamante.

Se invece la chiave è stata letta correttamente, si cercano di leggere tutte le **subkeys** e tutti **values** di quest'ultima.


#### RegEnumKeyExA\
Si esegue innanzitutto un controllo sul numero di subkeys lette.

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/read_6.png}
\end{center}

Analizziamo quindi il caso in cui ci siano delle subkeys (ramo *else*)

\begin{center}
  \includegraphics[width=0.8\textwidth]{img/read_7.png}
\end{center}

Viene eseguito un **ciclo while**, annidato in un costrutto **do-while**, tramite il quale si ottengono tutte le *subkeys* della chiave considerata.

All'interno del *while* viene allocata un'area di memoria da 16 byte. L'indirizzo base di tale area viene assegnato alla variabile **pRVar1**. Ghidra identifica automaticamente tale variabile come un puntature alla struttura *RegistryInfo*. Tuttavia questa associazione è erronea in quanto l'indirizzo base è associato ad un'area di 16 byte e non di 52. 

Questo ci suggerisce la presenza di una *nuova struttura* di 16 bytes. Definiamo quindi una nuova struttura **Subkey**, e definiamone i campi sfruttando le informazioni presenti nel codice e nella documentazione.

#### Struttura Subkey\
Dal codice assembly possiamo intuire il tipo di dato dei primi due campi della struttura

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/read_8.png}
\end{center}

*EAX* è associato a *pRVar1*, in quanto la malloc di default scrive il valore di ritorno in EAX. Nella prima *MOV* viene scritto *EBX* nell'indirizzo puntato da *EAX*, quindi nel primo campo della struttura. In EBX è contenuto l'indirizzo base della variabile *regInfo*, per cui il primo campo della nuova struttura sarà un **puntatore ad una struttura *RegistryInfo***.

Nella seconda *MOV* viene scritto il valore di *EDI* all'interno dell'indirizzo di memoria puntato da *EAX+4*. *EDI* contiene *0* alla prima iterazione.

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/read_10.png}
\end{center}

Nelle iterazioni successive, *EDI* contiene invece un puntatore all'*ultima struttura allocata*. Infatti *EAX*, contenente l'indirizzo base dell'area allocata, viene copiato in *EBP*, e successivamente *EBP* viene copiato in *EDI*.

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/read_11.png}
\end{center}

Il secondo campo della struttura *subkey* contiene quindi un puntatore ad un'altra struttura *subkey*, ed in particolare un puntatore alla **subkey precedente**.

Questo ci indica che l'*insieme di tutte le subkeys* viene mantenuto tramite una **Linked List**, in cui ogni subkey mantiene il riferimento alla subkey precedente.

Per definire gli altri valori della struttura osserviamo che questi vengono pushati sullo stack e passati come input alla funzione **RegEnumKeyExA**.

\begin{center}
  \includegraphics[width=0.8\textwidth]{img/read_12.png}
\end{center}

Tramite la documentazione di questa funzione possiamo quindi intuire i campi della struttura.

```
  [in]                HKEY      hKey,
  [in]                DWORD     dwIndex,
  [out]               LPSTR     lpName,
  [in, out]           LPDWORD   lpcchName,
                      LPDWORD   lpReserved,
  [in, out]           LPSTR     lpClass,
  [in, out, optional] LPDWORD   lpcchClass,
  [out, optional]     PFILETIME lpftLastWriteTime
```

Come parametro **dwIndex** viene passato il campo al byte 8 della struttura. Possiamo quindi definire il **terzo campo** di **subkeys** come un *DWORD* che corrisponde all'indice della subkey corrente.

Come parametro **lpcchName** viene passato il campo al byte 12 della struttura. Possiamo quindi definire il **quarto campo** di **subkeys** come un *DWORD*, che corrisponde alla size del nome della subkey.

In definitiva, definiamo la struttura come segue:

\begin{center}
  \includegraphics[width=0.8\textwidth]{img/read_13.png}
\end{center}

Continuando con l'analisi del codice, vediamo che quando una chiave non ha altre subkey, si ottiene la lista di tutti i values ad essa collegati.

\begin{center}
  \includegraphics[width=0.8\textwidth]{img/read_14.png}
\end{center}

Infatti *RegEnumKeyExA* ritorna 0 solo se la chiamata ha *avuto successo* e *ci sono altre subkey*; in quel caso si esegue il *break* e si passa alla subkey successiva. Se invece il valore di ritorno è un altro (*var2!=0*) si verifica se effettivamente sono state lette tutte le subkeys (*regInfo->subKeysNumber <= index1*) e si jumpa alla label **no_subkeys1**.

\newpage

#### RegEnumValueA\
In questa porzione di programma vengono letti tutti i **values** presenti all'interno dell'*hkey* specificata.

\begin{center}
  \includegraphics[width=0.8\textwidth]{img/read_15.png}
\end{center}

Viene allocata nuovamente un'area di memoria, in questo caso di 16660 byte. Ciò ci indica la presenza di una *terza struttura*, che presumibilmente conterrà tutte le informazioni relative ad un *value*. Andiamo quindi a definire una nuova struttura denominata **Value**.

\begin{center}
  \includegraphics[width=0.8\textwidth]{img/read_16.png}
\end{center}

\newpage

#### Struttura Value\
Alcuni campi di questa struttura vengono passati come parametro alla funzione **RegEnumValueA**, quindi sfruttando la documentazione di questa funzione possiamo ricavare alcune informazioni sui campi della struttura *Value*.

```
  [in]                HKEY    hKey,
  [in]                DWORD   dwIndex,
  [out]               LPSTR   lpValueName,
  [in, out]           LPDWORD lpcchValueName,
                      LPDWORD lpReserved,
  [out, optional]     LPDWORD lpType,
  [out, optional]     LPBYTE  lpData,
  [in, out, optional] LPDWORD lpcbData

```
**field_0x8** corrisponde al terzo parametro *lpValueName*. Sfruttando la documentazione, vediamo che questo questo campo è quindi un **array di caratteri**, che contiene *nome del valore* + *carattere di terminazione*.

```
[out] lpValueName

A pointer to a buffer that receives the name of the value as a null-terminated string.
```

**field_0x4008** corrisponde al quarto parametro *lpcchValueName* ed è quindi un DWORD

**field_0x400c** corrisponde al sesto parametro *lpType* ed è quindi un DWORD

**field_0x4010** corrisponde al settimo parametro *lpData*. La documentazione ci indica come questo campo sia un *Array di Byte*
  
```
[out, optional] lpData

A pointer to a buffer that receives the data for the value entry. This parameter can be NULL if the data is not required.
```

**field_0x4110** corrisponde all'ottavo parametro *lpcbData* ed è quindi un DWORD

Inoltre vediamo che, analogamente a quanto visto con la struttura *subkeys*, anche in questo caso abbiamo una **Linked List**. In particolare **field_0x4** viene assegnato sempre alla variabile *pVVar2*, che contiene l'ultimo *value* letto.

Il primo campo della struttura, mantiene invece un puntatore alla struttura *regInfo*.

Possiamo quindi definire *Value* nel seguente modo:

\begin{center}
  \includegraphics[width=0.8\textwidth]{img/val_2.png}
\end{center}

## Struttura RegistryInfo (2)
Continuando con l'analisi del codice possiamo osservare altre due istruzioni interessanti, che ci permettono di definire gli *ultimi due parametri* della struttura *RegistryInfo*

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/val_3.png}
\end{center}

- **field_0x2c** contiene il puntatore all'*ultima subkey* che è stata letta
- **field_0x30** contiene il puntatore all'*ultimo value* che è stato letto

Possiamo quindi completare la struttura *RegistryInfo*, inserendo anche gli ultimi due campi precedentemente non definiti.

\begin{center}
  \includegraphics[width=0.7\textwidth]{img/val_4.png}
\end{center}

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/val_5.png}
\end{center}

\newpage

### open_key - Valore di ritorno
Una volte lette tutte le subkeys e tutti i value, se non ci sono stati errori viene ritornato **regInfo**. Questa variabile è il puntatore alla struttura che contiene tutte le informazioni del registro, compresi i puntatori alle linked list delle subkeys e dei values.

Ritornando quindi alla funzione *open_key*, vediamo che viene chiamata la funzione di libreria **RegCloseKey**, per chiudere la chiave precedentemente aperta.

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/op_0.png}
\end{center}

Come possiamo vedere dalla specifica, sia **open_key** che **read_registry** scrivono il proprio valore di ritorno nel registro *EAX*.

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/op_4.png}
\end{center}

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/op_1.png}
\end{center}

Nella funzione **open_key**, *EAX* conterrà quindi il valore ritornato da *read_key*, e quindi il puntatore alla struttura *RegistryInfo*. Questo valore viene copiato nel *registro EBX*

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/op_2.png}
\end{center}

Nella label per il *ritorno al main*, viene copiato *EBX* in *EAX*. 

\begin{center}
  \includegraphics[width=0.5\textwidth]{img/op_3.png}
\end{center}

Questo ci indica come il *valore ritornato da open_key* sia di tipo **RegistryInfo\***. Ghidra tuttavia interpreta tale valore come un **LPSTR\***, per cui andiamo modificarlo tramite **Retype Return**.

\begin{center}
  \includegraphics[width=0.7\textwidth]{img/op_5.png}
\end{center}

### FUN_00401790 - print_registry
Completata la descrizione di *read_key*, possiamo procedere con l'analisi del main. 

Se open_key è stata eseguita correttamente, viene chiamata la funzione **FUN_00401790**, passando come argomento un puntatore al campo *base* della struttura ritornata da *open_key*. 

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/m_0.png}
\end{center}

Tuttavia il passaggio di tale campo della struttura è descritto erroneamente da *ghidra*, in quanto non è riuscito a definire il tipo di dato del parametro di input.

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/print_0.png}
\end{center}

Analizziamo dunque nel dettaglio come il main passa l'argomento alla funzione *00401790*.

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/m_1.png}
\end{center}

Capiamo che questa funzione prende in input un parametro di tipo *RegistryInfo\**, in quanto:

- *open_key* ritorna il *puntatore a RegistryInfo* in *EAX*. 
- *EAX* viene messo sullo stack tramite *MOV* per passare l'argomento a *FUN_00401790*

Possiamo quindi ridefinire il parametro **undefined \*param_1** di **FUN_00401790** in **RegistryInfo\* registryData**.

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/print_1.png}
\end{center}

Vediamo che anche nel main viene riconosciuto correttamente il parametro passato alla funzione:

\begin{center}
  \includegraphics[width=0.4\textwidth]{img/last.png}
\end{center}

Analizzando più nel dettaglio questa funzione, vediamo che viene utilizzata la funzione di libreria **printf** per scrivere su standard output tutte le informazioni sul registro. Nell'ordine, i valori che vengono vengono stampati sono:

- **registryData->base**, contenente le *user-defined class* della chiave.
- **registryData->securityDescriptor**
- **registryData->lastWriteTime**, contenente il timestamp dell'ultima modifica sulla chiave
- tutte le **subkeys**
- tutti i **values**

Dopo aver stampato tutti questi valori, la funzione semplicemente *ritorna al main*. Focalizziamoci quindi su come vengono stampate queste informazioni.

\newpage

#### Subkeys\
Viene eseguito un *ciclo do-while*, partendo dall'*ultima subkey*, acceduta tramite il campo *lastSubkey* del parametro di input. Viene stampato quindi l'indice della subkey corrente, e si scorre l'intera linked list tramite il puntatore alla sottochiave precedente.

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/print_3.png}
\end{center}

Dopo aver stampato la prima subkey (*prevSubkey==0*), termina il ciclo while e si procede andando a stampare tutti i values.

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/print_5.png}
\end{center}

#### Values\
Si esegue anche in questo caso un *ciclo do-while*, partendo dall'ultimo value individuato tramite il campo *lastValue*. Vengono stampati il *nome* ed il *tipo* del valore corrente, per poi stampare l'intero campo *data* scorrendo uno per uno i singoli byte dell'array.

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/print_4.png}
\end{center}

Successivamente si accede al *value precedente* tramite il puntatore, scorrendo in questo modo l'*intera linked list* dei valori. Dopo aver stampato il primo value, il controllo torna al *main*, eseguendo la procedura di ritorno al chiamante.

### main (2)
Dopo aver terminato la descrizione della funzione *print_registry*, possiamo analizzare qual è il valore di ritorno del main.

\begin{center}
  \includegraphics[width=0.6\textwidth]{img/t_0.png}
\end{center}

Escludendo il primo controllo su argv[argc], vediamo che result viene settato a 1 dopo la chiamata open_key. Se questa ha avuto successo, (registryData!=0), viene settato result 
a 0. Quindi il programma ritorna 0 se il registro è stato letto correttamente, 1 altrimenti.

## Conclusione
Dopo aver completato l'analisi di tutte le funzioni invocate a partire dal main, è possibile descrivere il comportamento complessivo del programma.

Il main accetta due parametri:

- Il **codice** di una **root key**
- Il **path** della **subkey** che vogliamo analizzare.

Nel programma sono state definite 3 strutture dati:

- **Subkey**: Mantiene le informazioni su una subkey, ed il riferimento alla subkey precedente. 
- **Value**: Mantiene le informazioni su un value, ed il riferimento al value precedente.
- **RegistryInfo**: Mantiene le informazioni sul registro. In particolare tiene traccia delle linked list relative alle subkey ed ai values.

La prima funzione invocata dal main è **open_key**, che permette di aprire un handle verso il registro, e di leggere tutti i dati al suo interno. Questa funzione restituisce un puntatore ad una struttura **RegistryInfo**. 

Tale puntatore viene passato in input alla funzione **print_registry**, che stampa tutte le informazioni precedentemente lette dal registro. In particolare stampa anche la lista di subkeys e values, scorrendo le rispettive linked list.

Infine il programma termina, ritornando **1** se ci sono stati errori nella lettura del registro, **0** altrimenti. 